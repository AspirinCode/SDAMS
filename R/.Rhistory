newcoldata <- as(rawcoldata,"data.frame")
feat.names <- newdata$feat.names
rawresult <- lapply(seq_len(dim(newfeature)[1]), function (i) SDA.unit(
featurevec=newfeature[i,], phenodata = newcoldata, VOI = VOI))
results <- Reduce('comb', rawresult)
# qv_1part <- apply(results$X1pvalue, 2, qvalue::qvalue)
# qv_2part <- qvalue::qvalue(results$X2pvalue)
# nparams = dim(results$pointest)[2]/2
# df.results <- list(gamma = results$pointest[,1:nparams],
#                     beta = results$pointest[,-(1:nparams)],
#                     pv_gamma = results$X1pvalue[,1],
#                     pv_beta = results$X1pvalue[,2],
#                     qv_gamma = qv_1part[[1]]$qvalues,
#                     qv_beta = qv_1part[[2]]$qvalues,
#                     pv_2part = results$X2pvalue,
#                     qv_2part = qv_2part$qvalues,
#                     feat.names = feat.names)
# return(df.results)
return(results)
}
SDA(exampleSE,VOI = 'bb')
SDA(exampleSE,VOI = 'dd')
SDA.unit(featurevec=featureInfo[7,], phenodata = groupInfo, VOI = 'bb')
SDA.unit(featurevec=featureInfo[17,], phenodata = groupInfo, VOI = 'bb')
aft_model(featureInfo[17,],groupInfo)
aft_model(featureInfo[18,],groupInfo)
aft_model(featureInfo[15,],groupInfo)
aft_model(featureInfo[13,],groupInfo)
aft_model(featureInfo[11,],groupInfo)
aft_model(featureInfo[10,],groupInfo)
#------------------------------ SDAMS test -------------------------------------
library(SummarizedExperiment); library(trust)
aft_model(featureInfo[10,],groupInfo)
aft_model(featureInfo[10,],groupInfo$grouping)
groupInfo$grouping
dmatrix = model.matrix(~., data = groupInfo$grouping)[,-1]
dmatrix = as.matrix(dmatrix)
dmatrix = model.matrix(~., data = as.data.frame(groupInfo$grouping))[,-1]
dmatrix = as.matrix(dmatrix)
dmatrix
dmatrix = model.matrix(~., data = as.data.frame(groupInfo))[,-1]
dmatrix = as.matrix(dmatrix)
dmatrix
aft_model <- function(data_feature, phenodata, bw = 1){
y <- data_feature
n <- length(y)
dmatrix = model.matrix(~., data = as.data.frame(phenodata))[,-1]
dmatrix = as.matrix(dmatrix)
binit = rep(0, ncol(dmatrix))
if (bw == 1){an <- 1.144*sd(log(y)-as.vector(dmatrix%*%as.matrix(binit)))*
n^(-1/5)}
if (bw == 2){an <- sd(log(y)-as.vector(dmatrix%*%as.matrix(binit)))*n^(-1/5)}
if (bw == 3){an <- sd(log(y)-as.vector(dmatrix%*%as.matrix(binit)))*n^(-1/7)}
if (bw == 4){an <- sd(log(y)-as.vector(dmatrix%*%as.matrix(binit)))*n^(-1/9)}
if (bw == 5){an <- 4^(1/3)*
min(sd(log(y)-as.vector(dmatrix%*%as.matrix(binit))),
IQR(log(y)-as.vector(dmatrix%*%as.matrix(binit)))/1.34)*n^(-1/5)}
if (bw == 6){an <- (8*sqrt(2)/3)^(1/5)*
min(sd(log(y)-as.vector(dmatrix%*%as.matrix(binit))),
IQR(log(y)-as.vector(dmatrix%*%as.matrix(binit)))/1.34)*n^(-1/5)}
if (bw == 7){an <- 4^(1/3)*
min(sd(log(y)-as.vector(dmatrix%*%as.matrix(binit))),
IQR(log(y)-as.vector(dmatrix%*%as.matrix(binit)))/1.34)*n^(-1/3)}
kern <- dnorm
kern.1st <- function(x){-x*dnorm(x)}
kern.2nd <- function(x){(x^2-1)*dnorm(x)}
kern.cdf <- pnorm
e_diff <- function(beta.iter,dmatrix,y){
e.diff<- outer(-log(y)+as.vector(t(dmatrix%*%as.matrix(beta.iter))),
log(y)-as.vector(t(dmatrix%*%as.matrix(beta.iter))), '+')
return(e.diff)
}
loglikf_1 <- function(beta.iter, dmatrix, y){
e.diff<- e_diff(beta.iter,dmatrix,y)
loglik_value<- -1*sum(log(y))+sum(log(rowSums(kern(e.diff/an))/n/an))
return(loglik_value)
}
fbeta_1 <- function(beta.iter, dmatrix, y){
e.diff<- e_diff(beta.iter,dmatrix,y)
fbeta<- rep(NA, length(beta.iter))
for (p in 1:length(beta.iter)) {
x_vec <- dmatrix[,p]
x.diff<- outer(x_vec,-x_vec,'+')
fbeta[p]<- 1/an*sum(rowSums(kern.1st(e.diff/an)*x.diff)/
rowSums(kern(e.diff/an)))
}
return(fbeta)
}
fbeta_dev_1 <- function(beta.iter,dmatrix,y){
e.diff <- e_diff(beta.iter,dmatrix,y)
hessian.m <- matrix(NA, nrow = length(beta.iter),
ncol = length(beta.iter))
for (i in 1:length(beta.iter)) {
x_i <- dmatrix[,i]
x_i_diff<- outer(x_i,-x_i,'+')
for (j in 1:i) {
x_j <- dmatrix[,j]
x_j_diff <- outer(x_j,-x_j,'+')
hessian.m[j,i] <- hessian.m[i,j]<- 1/an/an*
sum((rowSums(kern.2nd(e.diff/an)*x_i_diff*x_j_diff)*
rowSums(kern(e.diff/an))-
rowSums(kern.1st(e.diff/an)*x_i_diff)*
rowSums(kern.1st(e.diff/an)*x_j_diff))/
(rowSums(kern(e.diff/an)))^2)
}
}
return(hessian.m)
}
objfun_1 <- function(beta.iter){
stopifnot(is.numeric(beta.iter))
f <- loglikf_1(beta.iter,dmatrix,y)
g <- fbeta_1(beta.iter,dmatrix,y)
B <- as.matrix(fbeta_dev_1(beta.iter,dmatrix,y))
list(value =f, gradient = g, hessian = B)
}
trust.results <- try(trust(objfun_1, binit, 1, 5, minimize = FALSE),
silent = TRUE)
if (class(trust.results) == 'try-error') {
return(list(pointest = rep(NA, ncol(dmatrix)),
seest = rep(NA, ncol(dmatrix)),
null.deviance = NA, residual.deviance = NA))
}
else {
beta.est <- trust.results$argument
se.est <- try(sqrt(diag(-1*solve(trust.results$hessian))), silent = TRUE)
if (class(se.est) == 'try-error'){se.est = rep(NA, ncol(dmatrix));
null.deviance = 0; residual.deviance = 0}
else {
se.est <- se.est
null.deviance <- -2*loglikf_1(rep(0, ncol(dmatrix)), dmatrix, y)
residual.deviance <- -2*loglikf_1(beta.est, dmatrix, y)
}
return(list(pointest = beta.est,
seest = se.est,
null.deviance = null.deviance,
residual.deviance = residual.deviance))
}
}
aft_model(featureInfo[10,],groupInfo$grouping)
aft_model(featureInfo[11,],groupInfo$grouping)
aft_model(featureInfo[12,],groupInfo$grouping)
aft_model(featureInfo[12,],groupInfo)
aft_model(featureInfo[12,],groupInfo$bb)
source('SDA.R')
source('SDA_control.R')
source('result_summary.R')
source('datainput.R')
source('data_clean.R')
SDA.unit(featurevec=featureInfo[7,], phenodata = groupInfo, VOI = 'grouping')
SDA.unit(featurevec=featureInfo[7,], phenodata = groupInfo$grouping, VOI = 'grouping')
dim(groupInfo$grouping)
SDA.unit(featurevec=featureInfo[7,], phenodata = groupInfo$grouping)
SDA.unit(featurevec=featureInfo[7,], phenodata = as.data.frame(groupInfo$grouping))
source('SDA.R')
source('SDA_control.R')
source('result_summary.R')
source('datainput.R')
source('data_clean.R')
set.seed(100)
featureInfo <- matrix(runif(800, -2, 5), ncol = 40)
featureInfo[featureInfo<0] <- 0
rownames(featureInfo) <- paste("feature", 1:20, sep = '')
colnames(featureInfo) <- paste('subject', 1:40, sep = '')
groupInfo <- data.frame(grouping=matrix(sample(c(0,1), 40, replace = TRUE),
ncol = 1))
groupInfo <- data.frame(grouping=rnorm(40))
rownames(groupInfo) <- colnames(featureInfo)
groupInfo <- data.frame(grouping=as.factor(matrix(sample(0:1, 40, replace = TRUE),ncol = 1)),
bb = sample(c("a","b","c"), 40, replace = T),
dd = rnorm(40))
rownames(groupInfo) <- colnames(featureInfo)
source("datainput.R")
exampleSE <- createSEFromMatrix(feature = featureInfo, colData = groupInfo)
exampleSE
SDA.unit(featurevec=featureInfo[7,], phenodata = groupInfo, VOI = 'grouping')
SDA(exampleSE, VOI = 'grouping')
SDA(exampleSE, VOI = 'bb')
source('SDA.R')
source('SDA_control.R')
source('result_summary.R')
source('datainput.R')
source('data_clean.R')
SDA(exampleSE, VOI = 'bb')
SDA(exampleSE, VOI = 'dd')
aa=SDA(exampleSE, VOI = 'bb')
apply(aa$X1pvalue, 2, qvalue::qvalue)
aa=SDA(exampleSE, VOI = 'bb', pi0 = 1)
apply(aa$X1pvalue, 2, qvalue::qvalue, pi0 = 1)
aa=SDA(exampleSE, VOI = 'bb')
apply(aa$X1pvalue, 2, qvalue::qvalue, pi0 = 1)
apply(aa$X1pvalue, 2, qvalue, pi0 = 1)
library("qvalue", lib.loc="/Library/Frameworks/R.framework/Versions/3.4/Resources/library")
apply(aa$X1pvalue, 2, qvalue, pi0 = 1)
detach("package:qvalue", unload=TRUE)
apply(aa$X1pvalue, 2, qvalue::qvalue, pi0 = 1)
apply(aa$X1pvalue, 2, qvalue::qvalue, pi0 = 1)
apply(aa$X1pvalue, 2, qvalue::qvalue)
apply(aa$X2pvalue, 2, qvalue::qvalue)
aa
apply(aa$X2pvalue, 2, qvalue::qvalue)
apply(aa$X1pvalue, 2, qvalue::qvalue, lambda = seq(0.05, 0.75, 0.05))
apply(aa$X2pvalue, 2, qvalue::qvalue, lambda = seq(0.05, 0.75, 0.05))
apply(aa$X1pvalue, 2, qvalue::qvalue, lambda = seq(0.05, 0.75, 0.05))
seq(0.05, 0.75, 0.05)
seq(0.05, 0.5, 0.05)
apply(aa$X1pvalue, 2, qvalue::qvalue, lambda = seq(0.05, 0.5, 0.05))
apply(aa$X2pvalue, 2, qvalue::qvalue, lambda = seq(0.05, 0.5, 0.05))
testf1 = function(aa=1,bb=2){
aa+bb
}
testf2 = function(dd,...){
dd+testf1(...)
}
testf2(11)
testf2(11,aa=2)
testf2(11,aa=3)
testf2(11,aa=3,bb=1)
source('SDA_control.R')
aa=SDA(exampleSE, VOI = 'bb')
aa=SDA(exampleSE, VOI = 'bb', lambda = seq(0.05, 0.5, 0.05))
set.seed(100)
featureInfo <- matrix(runif(800, -2, 5), ncol = 40)
featureInfo[featureInfo<0] <- 0
rownames(featureInfo) <- paste("feature", 1:20, sep = '')
colnames(featureInfo) <- paste('subject', 1:40, sep = '')
groupInfo <- data.frame(grouping=matrix(sample(c(0,1), 40, replace = TRUE),
ncol = 1))
exampleSE <- createSEFromMatrix(feature = featureInfo, colData = groupInfo)
exampleSE
aa=SDA(exampleSE)
aa
aa=SDA(exampleSE,VOI = 'grouping')
bb=SDA(exampleSE)
identical(aa,bb)
exampleSE
colnames(exampleSE)
colnames(colData(exampleSE))
#------------------------------ SDAMS test -------------------------------------
library(SummarizedExperiment); library(trust)
source('SDA.R')
source('SDA_control.R')
source('result_summary.R')
source('datainput.R')
source('data_clean.R')
set.seed(100)
featureInfo <- matrix(runif(800, -2, 5), ncol = 40)
featureInfo[featureInfo<0] <- 0
rownames(featureInfo) <- paste("feature", 1:20, sep = '')
colnames(featureInfo) <- paste('subject', 1:40, sep = '')
groupInfo <- data.frame(grouping=matrix(sample(c(0,1), 40, replace = TRUE),
ncol = 1))
groupInfo <- data.frame(grouping=rnorm(40))
rownames(groupInfo) <- colnames(featureInfo)
exampleSE <- createSEFromMatrix(feature = featureInfo, colData = groupInfo)
exampleSE
aa=SDA(exampleSE)
exampleSE
groupInfo
set.seed(100)
featureInfo <- matrix(runif(800, -2, 5), ncol = 40)
featureInfo[featureInfo<0] <- 0
rownames(featureInfo) <- paste("feature", 1:20, sep = '')
colnames(featureInfo) <- paste('subject', 1:40, sep = '')
groupInfo <- data.frame(grouping=matrix(sample(c(0,1), 40, replace = TRUE),
ncol = 1))
rownames(groupInfo) <- colnames(featureInfo)
aa=SDA(exampleSE)
exampleSE <- createSEFromMatrix(feature = featureInfo, colData = groupInfo)
exampleSE
aa=SDA(exampleSE)
aa
directory1 <- system.file("extdata", package = "SDAMS", mustWork = TRUE)
path1 <- file.path(directory1, "ProstateFeature.csv")
directory2 <- system.file("extdata", package = "SDAMS", mustWork = TRUE)
path2 <- file.path(directory2, "ProstateGroup.csv")
exampleSE <- createSEFromCSV(path1, path2)
exampleSE
bb=SDA(exampleSE)
bb
bb$qv_2part
data_clean <- function(rawfeature, rawgroup){
ind <- which(rowSums(rawfeature>0)>=10)
feature <- rawfeature[ind, ]
group <- as.matrix(rawgroup)
feat.names <- rownames(feature)
return(list(feature = feature,
group = group,
feat.names = feat.names)
)
}
######## read data (two ways)   ########
#-------- get data from seperate matrix ---------
createSEFromMatrix <- function(feature, group) {
subjectName = rownames(group)
if (is(group, "numeric")) {
group <- as.data.frame(group)
colData <- as(group,'DataFrame')
rownames(colData) <- subjectName
colnames(colData)[1] <- "grouping"
}
if (is(group, "data.frame")) {
mgroup <- model.matrix(~group[,1])
group <- as.data.frame(mgroup[,2])
colData <- DataFrame(grouping=group)
rownames(colData) <- subjectName
colnames(colData)[1] <- "grouping"
}
if (is(group, "matrix")) {
group <- as.data.frame(group)
colData <- as(group,'DataFrame')
rownames(colData) <- subjectName
colnames(colData)[1] <- "grouping"
}
feature <- as.matrix(feature)
if (ncol(feature)!=nrow(group)) {
stop("Feature data and group data do not match!")
}
result <- SummarizedExperiment(assays = SimpleList(counts=feature),
colData = colData)
return(result)
}
# ------- import data from csv files ----------
createSEFromCSV <- function(featurePath, groupPath, rownames1 = 1,
rownames2 = 1, header1 = TRUE, header2 = TRUE){
feature <- read.csv(featurePath, row.names = rownames1, header = header1,
check.names = FALSE)
group <- read.csv(groupPath, row.names = rownames2, header = header2,
check.names = FALSE)
result <- createSEFromMatrix(feature = feature, group = group)
return(result)
}
comb <- function(list1, list2){
res <- list()
res$pointest <- rbind(list1$pointest, list2$pointest)
res$X1pvalue <- rbind(list1$X1pvalue, list2$X1pvalue)
res$X2pvalue <- rbind(list1$X2pvalue, list2$X2pvalue)
return(res)
}
SDA <- function(sumExp){
if (!is(sumExp, "SummarizedExperiment"))
stop("Input must be an object of SummarizedExperiment class!")
rawfeature <- assay(sumExp); rawgroup <- colData(sumExp)$grouping
newdata <- data_clean(rawfeature, rawgroup)
newfeature <- newdata$feature
newgroup <- newdata$group
feat.names <- newdata$feat.names
rawresult <- lapply(seq_len(dim(newfeature)[1]), function (i) SDA.unit(
featurevec=newfeature[i,], grouping=newgroup))
results <- Reduce('comb', rawresult)
qv_1part <- apply(results$X1pvalue, 2, qvalue::qvalue)
qv_2part <- qvalue::qvalue(results$X2pvalue)
df.results <- list(gamma = results$pointest[,1],
beta = results$pointest[,2],
pv_gamma = results$X1pvalue[,1],
pv_beta = results$X1pvalue[,2],
qv_gamma = qv_1part[[1]]$qvalues,
qv_beta = qv_1part[[2]]$qvalues,
pv_2part = results$X2pvalue,
qv_2part = qv_2part$qvalues,
feat.names = feat.names)
return(df.results)
}
aft_model <- function(data_feature, data_group, binit = 0, bw = 1){
x <- data_group; y <- data_feature
n <- length(y)
if (bw == 1){an <- 1.144*sd(log(y)-as.vector(x%*%as.matrix(binit)))*
n^(-1/5)}
if (bw == 2){an <- sd(log(y)-as.vector(x%*%as.matrix(binit)))*n^(-1/5)}
if (bw == 3){an <- sd(log(y)-as.vector(x%*%as.matrix(binit)))*n^(-1/7)}
if (bw == 4){an <- sd(log(y)-as.vector(x%*%as.matrix(binit)))*n^(-1/9)}
if (bw == 5){an <- 4^(1/3)*
min(sd(log(y)-as.vector(x%*%as.matrix(binit))),
IQR(log(y)-as.vector(x%*%as.matrix(binit)))/1.34)*n^(-1/5)}
if (bw == 6){an <- (8*sqrt(2)/3)^(1/5)*
min(sd(log(y)-as.vector(x%*%as.matrix(binit))),
IQR(log(y)-as.vector(x%*%as.matrix(binit)))/1.34)*n^(-1/5)}
if (bw == 7){an <- 4^(1/3)*
min(sd(log(y)-as.vector(x%*%as.matrix(binit))),
IQR(log(y)-as.vector(x%*%as.matrix(binit)))/1.34)*n^(-1/3)}
kern <- dnorm
kern.1st <- function(x){-x*dnorm(x)}
kern.2nd <- function(x){(x^2-1)*dnorm(x)}
kern.cdf <- pnorm
e_diff <- function(beta.iter, x, y){
e.diff <- outer(-log(y)+as.vector(t(x%*%as.matrix(beta.iter))),
log(y)-as.vector(t(x%*%as.matrix(beta.iter))), '+')
return(e.diff)
}
loglikf_1 <- function(beta.iter, x, y){
e.diff <- e_diff(beta.iter, x, y)
loglik_value <- -1*sum(log(y)) + sum(log(rowSums(kern(e.diff/an))/n/an))
return(loglik_value)
}
fbeta_1 <- function(beta.iter, x, y){
e.diff <- e_diff(beta.iter, x, y)
fbeta <- rep(NA, length(beta.iter))
for (p in seq_len(length(beta.iter))) {
x_vec <- as.matrix(x)[,p]
x.diff <- outer(x_vec, -x_vec, '+')
fbeta[p] <- 1/an*sum(rowSums(kern.1st(e.diff/an)*x.diff)/
rowSums(kern(e.diff/an)))
}
return(fbeta)
}
fbeta_dev_1 <- function(beta.iter, x, y){
e.diff <- e_diff(beta.iter, x, y)
hessian.m <- matrix(NA, nrow = length(beta.iter),
ncol = length(beta.iter))
for (i in seq_len(length(beta.iter))) {
x_i <- as.matrix(x)[,i]
x_i_diff <- outer(x_i, -x_i, '+')
for (j in seq_len(length(beta.iter))) {
x_j <- as.matrix(x)[,j]
x_j_diff <- outer(x_j,-x_j,'+')
hessian.m[i,j] <- 1/an/an*sum(
(rowSums(kern.2nd(e.diff/an)*x_i_diff*x_j_diff)*
rowSums(kern(e.diff/an))-rowSums(kern.1st(e.diff/an)*x_i_diff)*
rowSums(kern.1st(e.diff/an)*x_j_diff))/
(rowSums(kern(e.diff/an)))^2)
}
}
return(hessian.m)
}
objfun_1 <- function(beta.iter){
stopifnot(is.numeric(beta.iter))
f <- loglikf_1(beta.iter, x, y)
g <- fbeta_1(beta.iter, x, y)
B <- as.matrix(fbeta_dev_1(beta.iter, x, y))
list(value =f, gradient = g, hessian = B)
}
trust.results <- try(trust(objfun_1, binit, 1, 5, minimize = FALSE),
silent = TRUE)
if (class(trust.results) == 'try-error') {
return(list(pointest = NA, seest = NA, null.deviance = NA,
residual.deviance = NA))
}
else {
beta.est <- trust.results$argument
se.est <- try(sqrt(-1*solve(trust.results$hessian))[1,1], silent = TRUE)
if (class(se.est) == 'try-error'){se.est = NA; null.deviance = 0;
residual.deviance = 0}
else {
se.est <- se.est
null.deviance <- -2*loglikf_1(0, x, y)
residual.deviance <- -2*loglikf_1(beta.est, x, y)
}
return(list(pointest = beta.est,
seest = se.est,
null.deviance = null.deviance,
residual.deviance = residual.deviance))
}
}
SDA.unit <- function(featurevec, grouping, bw = 1){
data0 <- data.frame(featurevec, grouping)
data_binary <- data0
data_binary$featurevec[data_binary$featurevec>0] <- 1
data_AFT <- data0[data0$featurevec>0,]
non0_cnt <- c(sum(data_binary$featurevec[data_binary$grouping==0]==1),
sum(data_binary$featurevec[data_binary$grouping==1]==1))
zero_cnt <- c(sum(data_binary$featurevec[data_binary$grouping==0]==0),
sum(data_binary$featurevec[data_binary$grouping==1]==0))
group_size <- c(sum(data0$grouping==0),sum(data0$grouping==1))
if(any(non0_cnt == group_size)){
coef_logit <- NA; se_logit <- NA
aft_summary <- aft_model(data_AFT$featurevec, data_AFT$grouping,
bw = bw)
coef_aft <- aft_summary$pointest; se_aft <- aft_summary$seest
diff.dev.logit <- 0
diff.dev.aft <- aft_summary$null.deviance -
aft_summary$residual.deviance
}
else if(any(non0_cnt<2) ||
all(data_AFT$featurevec[1]==data_AFT$featurevec)){
coef_aft <- NA; se_aft <- NA
logit_reg <- glm(data_binary$featurevec ~ data_binary$grouping,
family = 'binomial', control = list(maxit = 50))
logit_summary <- summary(logit_reg)
coef_logit <- logit_summary$coefficients[2,1]
se_logit <- logit_summary$coefficients[2,2]
diff.dev.logit <- logit_summary$null.deviance - logit_summary$deviance
diff.dev.aft <- 0
}
else{
logit_reg <- glm(data_binary$featurevec ~ data_binary$grouping,
family = 'binomial', control = list(maxit = 50))
logit_summary <- summary(logit_reg)
coef_logit <- logit_summary$coefficients[2,1]
se_logit <- logit_summary$coefficients[2,2]
aft_summary <- aft_model(data_AFT$featurevec, data_AFT$grouping,
bw = bw)
coef_aft <- aft_summary$pointest; se_aft <- aft_summary$seest
diff.dev.logit <- logit_summary$null.deviance - logit_summary$deviance
diff.dev.aft <- aft_summary$null.deviance -
aft_summary$residual.deviance
}
if (diff.dev.logit == 0) {p_logit <- NA}
else {p_logit <- 1 - pchisq(diff.dev.logit, 1)}
if (diff.dev.aft == 0) {p_aft <- NA}
else {p_aft <- 1 - pchisq(diff.dev.aft, 1)}
diff.total <- diff.dev.logit + diff.dev.aft
if ((diff.dev.logit == 0)|(diff.dev.aft == 0)) {
X2pv <- 1 - pchisq(diff.total, 1)
} else {
X2pv <- 1 - pchisq(diff.total, 2)
}
return(list(pointest = c(coef_logit, coef_aft),
X1pvalue = c(p_logit, p_aft),
X2pvalue = X2pv)
)
}
aa=SDA(exampleSE)
identical(aa,bb)
